class MiddlewareService extends Service
{
  private static inline Buf(128) buf; // 16 component levels x 8 characters

  private static inline BufOutStream(buf) outBuf;

  ////////////////////////////////////////////////////////////////
  // Properties
  ////////////////////////////////////////////////////////////////
  @config @asStr property Buf(64) host
  @config property int port = 1883

  @config @asStr property Buf(16) clientid
  @config @asStr property Buf(16) username
  @config @asStr property Buf(16) password
  
  @config property bool autoStart = false

  @config property int componentsPerCycle = 1

  @unit=Units.percent
  @readonly property float componentsScanned = 0.0

  @readonly property int registeredSlots = 0

  define int Connecting = 0
  define int Handshake = 1
  define int Connected = 2
  define int GoodBye = 3
  define int Disconnected = 4
  define int InternalError = 5
  define int Down = 6

  define Str NetworkStatus = "Connecting, Handshake, Connected, GoodBye, Disconnected, InternalError, Down"
  @range=NetworkStatus
  @readonly property byte status = Disconnected

  ////////////////////////////////////////////////////////////////
  // Life cycle
  ////////////////////////////////////////////////////////////////

  **
  ** Init and start CBC middleware service 
  **
  virtual override void start()
  {
    if (autoStart)
      connect()
  }

  ** 
  ** Stop middleware service
  ** 
  virtual override void stop()
  {
    disconnect()
  }

  **
  ** disconnect and reconnect to MQTT broker
  **
  action void reconnect()
  {
    disconnect();
    status := getStatus();
    connect();
  }


  ** 
  ** connect to MQTT broker and start a new session
  ** 
  action void connect()
  {
    if (status == Connecting || status == Connected || handle != null)
      return

    handle = startSession(host.toStr(), port, clientid.toStr(), username.toStr(), password.toStr())
    if (handle != null) {
      log.message("Connected")
      sessionStartTime = Sys.ticks()
    } else {      
      log.error("Connection")
    }
    status := getStatus()
  }

  ** 
  ** Removes all slot registrations and restart scanning for 'regMqtt' methods
  ** 
  action void restartScan()
  {
    if (handle != null) {
      curCompId = 0
      registeredSlots := 0
      unregisterAllSlots(handle)
    }
  }

  ** 
  ** close the current MQTT session and disconnect to MQTT broker
  ** 
  action void disconnect()
  {
    if (handle == null || status == Disconnected)
      return

    status := GoodBye
    stopSession(handle);
    status := getStatus()
  }

  **
  ** Perform a chunk of background work.  Return true
  ** if there is pending work or false if the service is
  ** done working this cycle.
  **
  ** A service should be designed to function correctly no
  ** matter how many times work is called per execution cycle.
  ** Returning false is not a guarantee that work will not be
  ** called again in a given execution cycle; rather, it is
  ** a hint to the App execution engine that this service does
  ** not have any more work to do.
  **
  ** If you only want to do work once per execution cycle, you should consider:
  **
  ** 1) Moving your work into the execute() callback. execute() will only be
  ** called once per execution cycle.
  **
  ** 2) Set a "newCycle" flag in your execute() method and unset it after
  ** doing one work cycle.  Only do your work if the newCycle flag is set.
  **
  override bool work()
  {
    if(!Sys.app.isSteadyState())
      return false

    if (handle == null)
      return false

    App app = Sys.app
    if (curCompId >= app.compsLen)
      return false
    
    // Visit all components
    for(int i = 0; i < componentsPerCycle; i++) {
        registerComponent(app.comps[curCompId++])
        componentsScanned := 100.0 * (float)curCompId / (float)app.compsLen        
    }
    registeredSlots := getRegisteredSlots(handle)
    log.message("Scanned $curCompId/$app.compsLen ($componentsScanned%, $registeredSlots slots)")

    return curCompId < app.compsLen
  }


  ////////////////////////////////////////////////////////////////
  // Methods
  ////////////////////////////////////////////////////////////////
  public Obj getHandle()
  {
    if (isSessionLive(handle))
      return handle
    else
      return null
  }

  private void registerComponent(Component c)
  {
    if (c == null)
      return

    Type t = c.type
    log.message("Check $c.name [$c.type.name]...")

    Slot regAction = t.findSlot("regMqtt")
    if (regAction != null) {
      log.message("Register $c.name ...")
      invokeVoid(regAction)
    }
  }

  ** Get the MQTT topic from the component path
  static Str getTopicFromPath(Component targetComponent)
  {

    buf.clear();

    foreach (Component comp: targetComponent.path(), 16)
    {
      if (comp == null)
      {
        outBuf.printChar('\0'); // Terminate String
        break;
      }

      if (buf.size > 0)
        outBuf.print("/")
      outBuf.print(comp.name);
    }

    return buf.toStr();
  }
  
  // natives 
  **
  ** Start a middleware session to given host:port using clientid, username and password.
  ** a session handle object will be returned, that will be used by later
  ** native calls on this session.
  ** 
  static native Obj startSession(Str host, int port, Str clientid, Str username, Str password)

  ** 
  ** stop the middleware session for given session handle object
  ** 
  static native bool stopSession(Obj handle)

  ** 
  ** check if session for given session handle object live or not 
  ** 
  static native bool isSessionLive(Obj handle)

  ** 
  ** Get the connection state
  ** 
  static native int getStatus()

  ** 
  ** Register read-only slot like measured or computed values that are supposed to 
  ** be changed periodically. They are only published on change.
  **
  static native bool registerReadOnlySlot(Obj handle, Component component, Slot slot, Str path);

  ** 
  ** Register writable slot independent regarding their persistence or keep-alive policy. 
  ** The difference to monitor values is that the Sedona adapter will also submit a 
  ** subscription to the broker so that write requests on that parameter are forwarded 
  ** from other clients.
  **
  static native bool registerWritableSlot(Obj handle, Component component, Slot slot, Str path);

  ** 
  ** Register action slot
  **
  static native bool registerAction(Obj handle, Component component, Slot slot, Str path)

  ** 
  ** Check if given component has at least one registered slot.
  **
  static native bool isComponentRegistered(Obj handle, Component c)

  ** 
  ** Check if given component is registered.
  **
  static native bool isSlotRegistered(Obj handle, Component component, Slot slot)

  ** 
  ** Unregister the given slot from the middleware.
  **
  static native bool unregisterSlot(Obj handle, Component component, Slot slot)

  ** 
  ** Unregister the given slot from the middleware.
  **
  static native bool unregisterAllSlots(Obj handle)

  **
  ** Enables (disables) all slots of the given component if condition is true (false).
  **
  static native bool enableComponentIf(Obj handle, Component component, bool condition)

  **
  ** Enables (disables) the given slot if condition is true (false).
  **
  static native bool enableSlotIf(Obj handle, Component component, Slot slot, bool condition)

  **
  ** Check the given slot is enabled or disabled.
  **
  static native bool isSlotEnabled(Obj handle, Component component, Slot slot)

  **
  ** Get the number of registered slots.
  **
  static native int getRegisteredSlots(Obj handle)

  ////////////////////////////////////////////////////////////////
  // Fields
  ////////////////////////////////////////////////////////////////
  define Log log

  private Obj handle = null
  private int curCompId = 0
  private long sessionStartTime = 0L
}
